# vim: ts=2 sw=2 et ft=org
#+STYLE: <LINK href="stylesheet.css" rel="stylesheet" type="text/css" />
#+TITLE: Automated Testing with Nitrogenb
#+AUTHOR: Jesse Gumm (@jessegumm)
#+OPTIONS:   H:2 num:1 toc:1 \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+EMAIL: 

#+TEXT: [[http://nitrogenproject.com][Home]] | [[file:./index.org][Getting Started]] | [[file:./api.org][API]] | [[file:./elements.org][Elements]] | [[file:./actions.org][Actions]] | [[file:./validators.org][Validators]] | [[file:./handlers.org][Handlers]] | [[file:./config.org][Configuration Options]] | [[file:../plugins.org][Plugins]] | [[file:./jquery_mobile_integration.org][Mobile]] | [[file:./troubleshooting.org][Troubleshooting]] | [[file:./about.org][About]]
#+HTML: <div class=headline>Automated Testing with Nitrogen</div>

* Overview 

  Nitrogen has a simple unit testing framework which runs on the server and in
  the browser, and can be used for testing the functionality of your
  application, ensuring that objects render properly in the browser, and that
  actions are wired in the browser appropriately.

  This means that currently, you need to be able to run it on a machine with a
  browser in it, or there is an option to initiate a test from an external
  browser.

** The testing system consists of three layers:

*** 1. Individual Tests

    Each individual test is initiated by a call to one of the =?wf_test= macros
    and is used to test some simple cause and effect.

    There are a few different ways to initiate a test:

    + =?wf_test_auto(TestName, SetupFun, AssertionFun)= :: This is the most
      basic form of test. The test system will call =SetupFun()=, and what that
      completes, will automatically initiate a postback that will call
      =AssertionFun()=.  AssertionFun is expected to return =true=. Anything else
      will result in the test failing.

      An example that tests that a value was properly set in the browser might be:

      #+BEGIN_SRC erlang
      tests() ->
        SetupFun = fun() -> wf:set(my_textbox, "Value") end,
        AssertionFun = fun() -> wf:q(my_textbox) == "Value" end,
        ?wf_test_manual(set_textbox, SetupFun, AssertionFun).
      #+END_SRC

      If something is broken for some reason, (most common would be a typo in
      the name of the element), then =wf:q(my_textbox)= would not return the
      expected value, and the test would fail.

    + =?wf_test_manual(TestName, SetupFun, AssertionFun)= :: This is very
      similar to the =?wf_test_auto= test, except that the postback is not
      automatically executed.  Instead, you need to tell the test how to initiate
      the postback.  The easiest way would be with the =#event{}= or =#click{}=
      actions.

      An example of this might be to ensure that the expected postback is assigned to a button:

      #+BEGIN_SRC erlang
      tests() ->
        SetupFun = fun() -> wf:wire(my_button, #click{}) end,
        AssertionFun = undefined,
        ?wf_test_manual(button_works, SetupFun, AssertionFun)
      #+END_SRC

      And in the =event/1= function that =my_button= posts back to, you would add:

      #+BEGIN_SRC erlang
        ?wf_test_event(button_works)
      #+END_SRC

      Note that this is safe to include in your normal posbacks, since if the
      test is not running, this call will not do anything.

    + =?wf_test_js(TestName, SetupFun, JS, AssertionFun)= :: This test method
      allows you to collect arbitrary javascript properties (like if you want to
      verify that an element on the page has a certain height, or maybe that some
      global javascript variable has been set to a specific value).  The
      arguments are *very* similar, except for a few changes.

      + =SetupFun= is exactly the same as in =?wf_test_manual= in that you do
        not need to execute a postback in it.
      + =JS= is a Javascript string that returns a value (the last call should
        be actuall have a =return= statement, as it's executed inside a javascript
        function). This value will be passed to the =AssertionFun= function.
      + =AssertionFun= is expected to be a function of arity 1, with the only
        argument being a list containing the return value(s) from =JS=.

      Here's an example to illustrate the usage.  Here we will add a =#panel=
      (which is just an HTML =div=), then verify that its width is greater than
      zero:

      #+BEGIN_SRC erlang
        SetupFun = fun() -> wf:insert_top(my_wrapper, #panel{id=my_new_panel, text="Hi Mom!"} end,
        JS = "return objs('my_wrapper').width()",
        AssertFun = fun([Width]) -> is_integer(Width) andalso Width > 0 end,
        ?wf_test_js(element_added, SetupFun, JS, AssertFun).
      #+END_SRC

**** Options

     There is an optional last argument that can be passed to each of these
     macros: A proplist containing options for =delay= and =timeout=

     + =delay= (=integer()=) :: The number of milliseconds to wait before
       executing the =JS= term (if using =?wf_test_js=) or to wait before
       executing the postback (if using =?wf_test_auto= or =?wf_test_manual=).
       This would be used to allow a test to /process/ before executing (say, an
       image may need to be downloaded, or some jquery-ui scripts will need to be
       run, or we need to wait for another postback to happen before getting the
       data).  This gives your script time to run before checking the value.

     + =timeout= (=integer()=) :: The number of milliseconds the testing system
       is willing to wait for the test to complete before timing out.  This might
       be tripped if something is taking much longer than expected, or if
       javascript crashes and stops processing postbacks, or something else
       crashes.  It will just mean that the =?wf_test_event= macro was ultimately
       never called (which is done automatically if you're using =?wf_test_auto=
       or =?wf_test_js=).

*** 2. Test Pages
   
   - which consist of a series of individual tests executed in
     order, and

*** 3. Chain of pages
    
    , each of which runs some tests, and when the tests
     complete, redirect to the next page.



** See Also

